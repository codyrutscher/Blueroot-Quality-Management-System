// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  password  String?
  role      Role     @default(USER)
  department String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  documents      Document[]
  searches       SearchHistory[]
  templates      Template[]
  approvals      Approval[]
  sharedDocuments DocumentShare[] @relation("SharedDocuments")
  sharedByUser   DocumentShare[] @relation("SharedByUser")
  
  @@map("users")
}

model Document {
  id              String         @id @default(cuid())
  title           String
  filename        String
  filepath        String
  mimetype        String
  size            Int
  content         String?
  summary         String?
  status          DocStatus      @default(PROCESSING)
  category        DocCategory    @default(GENERAL)
  tags            String[]
  templateId      String?
  productId       String?
  workflowStatus  WorkflowStatus @default(DRAFT)
  version         Int            @default(1)
  isLatest        Boolean        @default(true)
  parentDocumentId String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  
  userId          String
  user            User           @relation(fields: [userId], references: [id])
  template        Template?      @relation(fields: [templateId], references: [id])
  product         Product?       @relation(fields: [productId], references: [id])
  parentDocument  Document?      @relation("DocumentVersions", fields: [parentDocumentId], references: [id])
  childDocuments  Document[]     @relation("DocumentVersions")
  
  embeddings      DocumentEmbedding[]
  searches        SearchHistory[]
  approvals       Approval[]
  shares          DocumentShare[]
  
  @@map("documents")
}

model DocumentEmbedding {
  id         String   @id @default(cuid())
  documentId String
  chunkIndex Int
  content    String
  vectorId   String   @unique
  createdAt  DateTime @default(now())
  
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  
  @@map("document_embeddings")
}

model SearchHistory {
  id        String   @id @default(cuid())
  query     String
  results   Json?
  userId    String
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id])
  documents Document[]
  
  @@map("search_history")
}

enum Role {
  USER
  ADMIN
  MANAGER
}

enum DocStatus {
  PROCESSING
  READY
  ERROR
  EDIT_MODE
  SIGNED
}

enum DocCategory {
  GENERAL
  QUALITY_MANUAL
  PROCEDURE
  WORK_INSTRUCTION
  FORM
  SPECIFICATION
  TRAINING
  COMPLIANCE
}

enum WorkflowStatus {
  DRAFT
  IN_REVIEW
  APPROVED
  REJECTED
  ARCHIVED
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

model Product {
  id                   String    @id @default(cuid())
  brand                String
  sku                  String    @unique
  productName          String
  healthCategory       String?
  therapeuticPlatform  String?
  nutrientType         String?
  format               String?
  numberOfActives      String?
  bottleCount          String?
  unitCount            Int       @default(0)
  manufacturer         String?
  containsIron         Boolean   @default(false)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  
  documents            Document[]
  
  @@map("products")
}

model Template {
  id          String   @id @default(cuid())
  name        String
  description String?
  type        String   @default("FINISHED_PRODUCT_SPEC")
  content     Json
  isActive    Boolean  @default(true)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  creator     User       @relation(fields: [createdBy], references: [id])
  documents   Document[]
  
  @@map("templates")
}

model Approval {
  id         String         @id @default(cuid())
  documentId String
  approverId String
  status     ApprovalStatus @default(PENDING)
  comments   String?
  approvedAt DateTime?
  createdAt  DateTime       @default(now())
  
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  approver   User     @relation(fields: [approverId], references: [id])
  
  @@map("approvals")
}

model DocumentShare {
  id          String   @id @default(cuid())
  documentId  String
  sharedWith  String
  sharedBy    String
  permissions String   @default("read")
  createdAt   DateTime @default(now())
  
  document    Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  sharedUser  User     @relation("SharedDocuments", fields: [sharedWith], references: [id], onDelete: Cascade)
  sharer      User     @relation("SharedByUser", fields: [sharedBy], references: [id])
  
  @@map("document_shares")
}